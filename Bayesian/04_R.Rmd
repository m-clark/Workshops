# R

R has many tools for Bayesian analysis, and possessed these before Stan came around.  Among the more prominent were those that allowed the use of BUGS (e.g. <span class="pack">r2OpenBugs</span>), one of its dialects JAGS (<span class="pack">rjags</span>), and packages like <span class="pack">coda</span> and <span class="pack">MCMCpack</span> that allowed for customized approaches, further extensions or easier implementation.  Other packages might regard a specific type or family of models (e.g. <span class="pack">bayesm</span>), but otherwise be mostly R-like in specifying the model (e.g. <span class="pack">MCMCglmm</span> for mixed models).  

Now it is as easy to conduct standard and complex models using Stan while staying within the usual framework of R-style modeling.  You don't even have to write Stan code!  I'll note a couple relevant packages that enable this.


## rstan

The <span class="pack">rstan</span> package is the workhorse, and the other packages mentioned here rely on it.  In general though it's what you will use when you write Stan code directly. The following code demonstrates how.

### Data list

First you'll need to create a list of objects we'll call the <span class="emph">data list</span>. It is a list of *named* objects that Stan will look to match to the things you noted in the `data{}` section of your Stan code.  In our example, our data statement has four components- X, y, N, and K.  As such, we might create the following data list.

```{r dataList, eval=FALSE}
dataList =  list(X=mymatrix, y=mytarget, N=1000, K=ncol(mymatrix))
```

You could add fixed parameters and similar if your Stan code relies on them somewhere, but at this point you're ready to proceed.  Here is a model using RStan.

```{r rstan, eval=FALSE}
library(rstan)

modResults = stan(mystancode, data=dataList, iter=2000, warmup=1000)
```

The Stan code is specified as noted previously, and can be a string in the R environment, or a separate text file[^stringvsfile].  

### Debug model

The debug model is just like any other except you'll only want a couple interations and for one chain.

```{r rstanDebug, eval=FALSE}
modRun_0 = stan(mystancode, data=dataList, iter=10)
```

This will allow you to make sure the Stan code  compiles first and foremost, and secondly, that there aren't errors in the program that keep parameters from being estimated (thus resulting in no posterior samples).  If you set the iterations a little higher, you may also discover potential difficulties in the estimation process that might suggest code issues.


### Full model

If all is well with the previous, you can now proceed with the main model.  Setting the argument `fit = modRun_0` will save you the time spent compiling. It is a notable time saver to run the chains in parallel by setting `cores = ncore`, where `ncore` is some value representing the number of cores on your machine you want to use.

### Model summary

The typical model summary provides parameter estimates, standard errors, interval estimates and two diagnostics- effective sample size, the $\hat{R}$ diagnostic.

```{r runStan, eval=FALSE, echo=FALSE}
stanmod = '
data {                      // Data block
  int<lower=1> N;           // Sample size
  int<lower=1> K;           // Dimension of model matrix
  matrix[N, K] X;           // Model Matrix
  vector[N] y;              // Target variable
}

transformed data {          // Transformed data block.
} 

parameters {                // Parameters block
  vector[K] beta;           // Coefficient vector
  real<lower=0> sigma;      // Error scale
}

transformed parameters {    // Transformed parameters block.
} 

model {                     // Model block
  vector[N] mu;
  mu = X * beta;            // Creation of linear predictor
  
  // priors
  beta ~ normal(0, 10);
  sigma ~ cauchy(0, 5);     
  
  // likelihood
  y ~ normal(mu, sigma);
}

generated quantities {         // Generated quantities block. 
  vector[N] yhat;                // linear predictor
  real Rsq;                    // R-squared
  real Intercept;
  real beta_1;
  
  yhat = X * beta;
  Rsq = 1 - dot_self(y-yhat)/dot_self(y);
  
  Intercept = beta[1];
  beta_1 = beta[2];
}'
n = 1000
X = cbind(1, runif(n))
dataList = list(X=X, y= c(X%*%c(1,.25)) + rnorm(n), N=nrow(X), K=ncol(X))
library(rstan)
mystanmodel = stan(model_code = stanmod, data=dataList, cores=4)
save(mystanmodel, file='data/stanmod.RData')
```

```{r, eval=FALSE, echo=3}
load('data/stanmod.RData')
library(rstan)
print(mystanmodel, pars=c('Intercept', 'beta_1', 'sigma', 'Rsq'), probs = c(.05,.95), digits=3)
# broom::tidy(mystanmodel) %>% 
#   filter(term %in% c('Intercept', 'beta_1', 'sigma', 'Rsq')) %>% 
#   pander::pander()
```


### Diagnostics and beyond

Typical Bayesian diagnostic tools like trace plots, density plots etc. are available.  Part of the printed output contains the two just mentioned. In addition <span class="pack">rstan</span> comes with model comparsion functions like <span class="func">WAIC</span> and <span class="func">loo</span>.  The best part is the launch_shiny function, which actually makes this part of the 

## rstanarm

The <span class="pack">rstanarm</span> is a package that allows you to specify models in the standard R format.  While this is very limiting, it definitely covers a lot of the usual statistical ground.  As such, it enables you to be a Bayesian for any of the very common glm settings, including mixed and additive models.

```{r rstanarm, eval=FALSE}
library(rstanarm)

modResults = stan_glm(y ~ x, family=binomial, data=mydataframe, iter=2000, warmup=1000)
```

I should note that <span class="pack">rstanarm</span> also has some 'big data' options via biglm, but the fact that it uses <span class="pack">biglm</span> makes me skeptical as to whether it is all that useful.

## brms

I have watched with much enjoyment the development of the <span class="pack">brms</span> package from nearly its inception.  Due to the continued development of rstanarm, it's role is becoming more niche, but I still believe it to be both useful and powerful.  It allows for many types of models, and any distributions (including truncated versions, ordinal variables, zero-inflation, etc.).  The main developer is ridiculously responsive to requests, so extensions are regularly implemented.  In short, for standard models you can use <span class="pack">rstanarm</span>, while for variations of those, more flexible manipulation of their priors, or more complex models, you can use <span class="pack">brms.</span> 


The following shows an example of a 'robust' regression based on a student $t$ likelihood rather than a normal, but also implementing truncation so that values can only fall between 0 and 100.  The ease of implementing truncation comes from Stan[^trunc], but otherwise, brms makes it potentially easy to use for many models we might want to pursue.

```{r brms, eval=FALSE}
library(brms)

modResults = brm(y | trunc(lb = 0, ub = 100) ~ x, family=student, data=dataList, iter=2000, warmup=1000)
```

[^stringvsfile]: I would maybe suggest using strings with simple models as you initially learn Stan/RStan, but a separate file is preferred. RStudio has syntax highlighting and other benefits for `*.stan` files.

[^trunc]: Or Bayesian modeling generally.

