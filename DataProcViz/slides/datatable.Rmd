```{r setupDatatable, include=FALSE, eval=TRUE}
knitr::opts_chunk$set(echo = T, message=F, warning=F, comment=NA, autodep=T, eval=FALSE, cache=FALSE,
                      R.options=list(width=120), fig.width=8, fig.align = 'center')
```


## 

<div style="text-align:center;font-variant:small-caps; font-size:200%; color:#1e90ff">Data.Table</div>

## data.table

<span class="pack">data.table</span> works in a notably different way than <span class="pack">dplyr</span>.

However, you'd use it for the same reasons.

Like <span class="pack">dplyr</span>, the data objects are both <span class="objclass">data.frames</span> and a package specific class.

Faster subset, grouping, update, ordered joins and list columns


## data.table

In general, <span class="pack">data.table</span> works with brackets as in base R.

However, the brackets work like a function call!

- Several key arguments

```{r}
x[i, j, by, keyby, with = TRUE, ...]
```


Importantly: 

*you can't use the brackets as you would with data.frames*.

```{r, eval=TRUE}
library(data.table)
df = data.table(x=sample(1:10, 6), g=1:3, y=runif(6))
df[,4]
```

## data.table

```{r}
x[i, j, by, keyby, with = TRUE, ...]
```

What **i** and **j** can be are fairly complex. 

In general, you use **i** for filtering by rows.

 
```{r, results='hold', eval=TRUE}
df[2]
df[2,]
```


## data.table

```{r}
x[i, j, by, keyby, with = TRUE, ...]
```

In general, you use **j** to select (by name!) or create new columns.

- Define a new variable with <span class="func">:=</span>

 
```{r, results='hold', eval=T}
df[,x]
df[,z:=x+y]  # df now has a new column
```


## data.table

Dropping columns is awkward.

- because **j** is an argument

```{r, eval=T, results='hold'}
df[,-y]             # creates negative values of y
df[,-'y', with=F]   # drops y, but now needs quotes
df[,y:=NULL]        # drops y, but this is just a base R approach
df$y = NULL
```




## Grouped operations

group-by, with creation of a new variable.

Note that these actually modify df *in place*.
```{r eval=T}
df1 = df2 = df
df[,sum(x,y), by=g]                  # sum of all x and y values
df1[,newvar := sum(x), by=g]         # add new variable to the original data 
df1
```



## Grouped operations

We can also create groupings on the fly.

For a new summary data set, we'll take the following approach.

```{r eval=T}
df2[, list(meanx = mean(x), sumx = sum(x)), by=g==1]
```



## Faster!

- joins: and easy to do (note that i can be a data.table)

```{r}
df1[df2]
```

- group operations: via setkey
- reading files: fread
- character matches: e.g. via chmatch


## Timings

The following demonstrates some timings from [here](http://stackoverflow.com/questions/3505701/r-grouping-functions-sapply-vs-lapply-vs-apply-vs-tapply-vs-by-vs-aggrega/34167477#34167477)

- Reproduced on my own machine
- based on 50 million observations
- Grouped operations are just a sum and length on a vector. 


By the way, never, ever use aggregate. For anything.

```{r, eval=TRUE, echo=FALSE}
load('../data/timing.RData')
as.data.table(sapply(timing, `[[`, "elapsed"), keep.rownames = TRUE)[,.(fun = V1, elapsed = V2)][order(-elapsed)]
```

Ever.

Really.

## Pipe with data.table

Can be done but awkward at best.

```{r}
mydf[,newvar:=mean(x),][,newvar2:=sum(newvar), by=group][,-'y', with=FALSE]
mydf[,newvar:=mean(x), 
  ][,newvar2:=sum(newvar), by=group
  ][,-'y', with=FALSE
  ]
```

Probably better to just use a pipe and dot approach

```{r}
mydf[,newvar:=mean(x),] %>% 
  .[,newvar2:=sum(newvar), by=group] %>% 
  .[,-'y', with=FALSE]
```

## My take

Faster methods are great to have. 

  - Especially for group-by and joins.

Drawbacks:

- Complex
- The syntax can be awkward
- It doesn't work like a data.frame
- Piping with brackets




## Compromise

If speed and/or memory is (potentially) a concern, data.table

For interactive exploration, dplyr

Piping allows one to use both, so no need to choose.