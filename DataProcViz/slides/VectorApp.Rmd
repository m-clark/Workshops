```{r setupVector, include=FALSE}
knitr::opts_chunk$set(echo = T, message=F, warning=F, comment=NA, autodep=T, eval=F,
                      R.options=list(width=120), fig.width=8, fig.align = 'center')
```

## 

<div style="text-align:center;font-variant:small-caps; font-family:TRON; font-size:200%; color:#1e90ff">Vectorization</div>

## Boolean Indexing

We can take values corresponding to some operation that results in `TRUE` or `FALSE`.

Assume x is a vector of numbers.

```{r boolindex}
idx = x > 2
idx
x[idx]
```

## Flexiblity

We actually don't have to create a Boolean object before using it. 

R indexing is ridiculously flexible.

```{r flexindex}
x[x > 2]
x[x != 3]
x[ifelse(x > 2, T, F)]
x[{y = idx; y}]
```

## Vectorized operations

Consider the following loop:

```{r loop}
for (i in 1:nrow(mydf)) {
  check = mydf$x[i] > 2
  if (check==TRUE){
    mydf$y[i] = 'Yes'
  } else {
    mydf$y[i] = 'No'
  }
}
```


## Vectorized operations

Compare:

```{r boolnoloop}
mydf$y = 'No'
mydf$y[mydf$x > 2] = 'Yes'
```

This gets us the same thing.



## Vectorized operations

Boolean indexing provides an example of a vectorized operation.

The whole vector is considered rather than each element individually.

This is always faster.

## Vectorized operations

Log all values in a matrix.

```{r vecmatrixop}
mymatrix_log = log(mymatrix)
```

Would be a lot faster than looping over elements, rows or columns.


## Vectorized Operations

Many vectorized functions already exist in R.

They are also often written in C, Fortran etc., and so even faster.
  


